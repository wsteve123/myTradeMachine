/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tradeMenus;

import ibTradeApi.ibApi;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.logging.Level;
import java.util.logging.Logger;
import positions.myUtils;

/**
 *
 * @author earlie87
 */
public class createOptionFilesForExchangesDialogForm extends javax.swing.JDialog {

    final String NASQ1 = "NasdaqQ1";
    final String NASQ2 = "NasdaqQ2";
    final String NASQ3 = "NasdaqQ3";
    final String NASQ4 = "NasdaqQ4";
    final String NYSEQ1 = "NyseQ1";
    final String NYSEQ2 = "NyseQ2";
    final String NYSEQ3 = "NyseQ3";
    final String NYSEQ4 = "NyseQ4";
    final String NYSEQ5 = "NyseQ5";
    final String NYSEQ6 = "NyseQ6";
    final String NYSEQ7 = "NyseQ7";
    final String NYSEQ8 = "NyseQ8";
    final String WATCH1 = "WATCH1";
    final String SNP1 = "SnP1";
    final String SNP2 = "SnP2";
    final String DOW = "Dow";
    
    //private String homeDirectory = "/Users/earlie87/NetBeansProjects/myTradeMachine/src/supportFiles/";
    private String homeDirectory = myUtils.getMyWorkingDirectory() + "/src/supportFiles/";
    private String actTickersFile = null;
    private String actContractFile = null;
    // this says to start new file or not
    private boolean createNew = true;
    String[] exchanges = {  NASQ1, NASQ2, NASQ3, NASQ4, 
                            NYSEQ1, NYSEQ2, NYSEQ3, NYSEQ4,
                            NYSEQ5, NYSEQ6, NYSEQ7, NYSEQ8, 
                            WATCH1, SNP1, SNP2, DOW
    };
    String selectedExchangeStr = exchanges[0];
    int selectedExchangeInt = 0;
    //this structure will hold all data for chosen exchange..
    readTickerFile exchangeData = null;
    //optionContractInfo allOptionData[] = null;
    getOptionData optionDat;
    boolean createFilesActionRunning = false;
    createFilesThread cfThread = null;
    int lastTickerProcessed = 0;
    int lastTickerWithContractProccessed;
    private ibApi actIbApi = ibApi.getActApi();
 
    private class OptionTag {
        String[] option;
    }
    private class optionContractData {
        //one stockTicker with many optionContracts..
        String stockTicker = null;
        boolean optionsAvailable = true;
        String[] optionTags = null;
    }
    optionContractData optionContracts[];
    /**
     * Creates new form createOptionFilesForExchangesDialogForm
     */
    public createOptionFilesForExchangesDialogForm(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();
        addWindowListener(
                new java.awt.event.WindowAdapter() {

                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        setVisible(false);
                        dispose();
                    }
                });

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        indexComboBox = new javax.swing.JComboBox();
        closeButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        createOptionFilesTextArea = new javax.swing.JTextArea();
        createFilesButton = new javax.swing.JButton();
        pauseResumeButton = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jLabel1.setText("Creates Option Files");

        jLabel2.setText("Select Index");

        indexComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "NasdaqQ1", "NasdaqQ2", "NasdaqQ3", "NasdaqQ4", "NyseQ1", "NyseQ2", "NyseQ3", "NyseQ4", "NyseQ5", "NyseQ6", "NyseQ7", "NyseQ8", "WATCH1", "SnP1", "SnP2", "Dow" }));
        indexComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SelectIndexComboBoxActionPerformed(evt);
            }
        });

        closeButton.setText("Close");
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });

        createOptionFilesTextArea.setColumns(20);
        createOptionFilesTextArea.setRows(5);
        jScrollPane1.setViewportView(createOptionFilesTextArea);

        createFilesButton.setText("createButton");
        createFilesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                createFilesButtonActionPerformed(evt);
            }
        });

        pauseResumeButton.setText("pauseResume");
        pauseResumeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pauseResumeButtonActionItem(evt);
            }
        });

        jLabel3.setText("Create New File");

        jLabel4.setText("Continue with existing File");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(172, 172, 172)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(indexComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(187, 187, 187)
                        .addComponent(jLabel2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(162, 162, 162)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(createFilesButton, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(185, 185, 185)
                        .addComponent(closeButton))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(23, 23, 23)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 459, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(163, 163, 163)
                        .addComponent(pauseResumeButton))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(132, 132, 132)
                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(97, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(27, 27, 27)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(indexComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(createFilesButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pauseResumeButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(closeButton)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void SelectIndexComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SelectIndexComboBoxActionPerformed
        // TODO add your handling code here:
        /* get the user selected exhange to later search in */
        if (indexComboBox.getItemCount() > 0) {
            selectedExchangeStr = indexComboBox.getSelectedItem().toString();
            selectedExchangeInt = indexComboBox.getSelectedIndex();
        };
        System.out.println("selected index is: " + selectedExchangeStr);
        System.out.println("selected index idx is : " + selectedExchangeInt);

    }//GEN-LAST:event_SelectIndexComboBoxActionPerformed

    private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        // TODO add your handling code here:
        setVisible(false);
        dispose();
    }//GEN-LAST:event_closeButtonActionPerformed
    public class ioWrTextFiles{
        String fname = homeDirectory;
        
        FileOutputStream fos;
        BufferedWriter bow;
        DataOutputStream dos;
        FileInputStream fis;
        BufferedReader bir;
        
        
        void openWr(String fileName, boolean append) {
            fname = fileName;
            
            
            try {
                //fos = new FileOutputStream(fileName);
                //dos = new DataOutputStream(fos);
                bow = new BufferedWriter(new FileWriter(fname, append));
                
                
                try {
                    fis = new FileInputStream(fname);
                    bir = new BufferedReader(new InputStreamReader(fis));
                
                } catch (Exception e) {
                    System.out.println("file does not exist " + fname); 
                    bow = new BufferedWriter(new FileWriter(fname, false));
                    fis = new FileInputStream(fname);
                    bir = new BufferedReader(new InputStreamReader(fis));
                  
                }
                
                
            } catch (Exception e) {
                System.out.println("error writing text to: " + fileName + "(" + e + ").");
            }
        }
        void closeWr() {
            try {
                bow.close();
                
               
            } catch (Exception e) {
                System.out.println("error closing file: " + fname + "(" + e + ").");
            }
            fname = homeDirectory;
        }
        ioWrTextFiles(String fileName, boolean append) {
            fname = homeDirectory;
            this.openWr(fileName, append);
            
        }
        boolean write(optionContractData optionCD, String str) {
            
            try {
                if (str != null){
                    bow.write(str);
                    bow.newLine();
                    bow.flush();
                }else if (optionCD != null){
                    int idx;
                    int tlen;
                    tlen = optionCD.optionTags.length;
                    bow.write(optionCD.stockTicker);
                    bow.newLine();
                    bow.flush();
                    for (idx = 0; idx < tlen; idx++ ) {
                        bow.write(optionCD.optionTags[idx]);
                        bow.newLine();
                        bow.flush();
                    }
                    
                }else{
                    return true;
                }
            } catch (Exception e) {
                System.out.println("error with file: " + fname + "(" + e + ").");
            }
            return true;
        }
        optionContractData read() {
            optionContractData optionCD = null;
            
            return optionCD;
        }
        String read(Boolean str)  {
            String rdStr = null;
            try {
                rdStr = bir.readLine();
            } catch (IOException ex) {
                Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(Level.SEVERE, null, ex);
            }
            return rdStr;
        }
    }
    public class ioRdTextFiles{
        String fname = homeDirectory;
        
        DataOutputStream dos;
        FileInputStream fis;
        BufferedReader bir;
        BufferedWriter bow;
        
        
        void openRd(String fileName, boolean append) {
            fname = fileName;
            
            
            try {
                fis = new FileInputStream(fname);
                bir = new BufferedReader(new InputStreamReader(fis));
            } catch (Exception e) {
                System.out.println("error reading text from: " + fname + "(" + e + ").");
                System.out.println("file does not exist " + fname); 
                try {
                    bow = new BufferedWriter(new FileWriter(fname, false));
                    fis = new FileInputStream(fname);
                } catch (IOException ex) {
                    Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                bir = new BufferedReader(new InputStreamReader(fis));
            }
        }
        void closeRd() {
            try {
                bir.close();
                
            } catch (Exception e) {
                System.out.println("error closing file: " + fname + "(" + e + ").");
            }
            fname = homeDirectory;
        }
        ioRdTextFiles(String fileName, boolean append) {
            fname = homeDirectory;
            this.openRd(fileName, append);
            
        }
        
        optionContractData read() {
            optionContractData optionCD = null;
            
            return optionCD;
        }
        String read(Boolean str)  {
            String rdStr = null;
            try {
                rdStr = bir.readLine();
            } catch (IOException ex) {
                Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(Level.SEVERE, null, ex);
            }
            return rdStr;
        }
    }
    public class createFilesThread extends Thread{
        int contractIdx = 0;
        int tickerIdx;
        int tickerWithContractIdx = 0;
        int chainSz = 0;
        String actTicker = null;
        ioWrTextFiles wrFile = null;
        ioRdTextFiles rdFile = null;
        ioWrTextFiles wrFileAux = null;
        boolean shutDown = false;
        
        int runXs = 0;
        boolean running = false;
        public createFilesThread(){
            
            running = true;
            this.start();
            
            
        }
        public void stopit(){
            running = false;
        }
        public void startit(){
            running = true;
        }
        public void windDown(){
            shutDown = true;
        }
        public void run() {
            
            if (createNew == true){
                wrFile = new ioWrTextFiles(actContractFile, false /*append*/);
                rdFile = new ioRdTextFiles(actContractFile+".his", true);
                wrFileAux = new ioWrTextFiles(actTickersFile + ".wo", false /* append */);
            }else {
                wrFile = new ioWrTextFiles(actContractFile, true /*append*/);
                rdFile = new ioRdTextFiles(actContractFile+".his", true);
                wrFileAux = new ioWrTextFiles(actTickersFile + ".wo", true /* append */);
            }
            ibApi.quoteInfo contract = new ibApi.quoteInfo();
            
            while (running) {
                try {
                    
                    System.out.println("thread running.. " + runXs++);
                    // this maybe a continuation so start where we left off..
                    
                    tickerIdx = lastTickerProcessed;                   
                    tickerWithContractIdx = lastTickerWithContractProccessed;
                    System.out.println("starting with ticker: " + tickerIdx);
                    
                    for (tickerIdx = tickerIdx; (tickerIdx < exchangeData.numberOfTickers) && !shutDown; tickerIdx++) {
                        actTicker = exchangeData.tickerDataHere[tickerIdx].stockTicker;
                        System.out.println("working on " + tickerIdx + " ticker: " + actTicker);
                        createOptionFilesTextArea.append("\nProcessing Ticker "+ 
                                                            actTicker + 
                                                            " (" + tickerIdx + " ,with options " + 
                                                            tickerWithContractIdx + ")"
                        );
                        if ((actTicker == null) || (exchangeData.tickerDataHere[tickerIdx].quoteAble == false)) {
                            System.out.println("actTicker == NULL?? or has '^'...skip it...");
                            if (actTicker != null) {
                                System.out.println("...actTicker: " + actTicker);
                            }
                            continue;   
                        }
                        if (actIbApi.apiAlarms.allOk(false /*hang*/) != true) {
                            /* if any connection problems with API, sleep */
                            System.out.println(" API connection Problem...");
                            while(actIbApi.apiAlarms.allOk(false /*hang*/) != true){
                                myUtils.delay(1000);
                            }
                            System.out.println(" API connection Problem Cleared...");
                        }
                        // we could end up with 20+ optionDat (contracts per ticker)
                        optionDat = new getOptionData(actTicker);

                        if (optionDat.noErrors == true) {
                            System.out.println("option exists.");
                            chainSz = optionDat.actChain.chainLeft();
                            System.out.println("chain size is: " + chainSz);
                            contract = optionDat.actChain.chainGetNext();
                    //just one ticker for many option contracts..

                            optionContracts[tickerWithContractIdx] = new optionContractData();
                            optionContracts[tickerWithContractIdx].stockTicker = contract.symbol;
                            optionContracts[tickerWithContractIdx].optionsAvailable = true;
                            //for every stock ticker there can be many option contracts (20 - 40, chainSz)...
                            optionContracts[tickerWithContractIdx].optionTags = new String[chainSz];
                            for (contractIdx = 0; contractIdx < chainSz; contractIdx++) {
                                optionContracts[tickerWithContractIdx].optionTags[contractIdx] = contract.optionSymbol;
                                contract = optionDat.actChain.chainGetNext();
                            }
                            wrFile.write(optionContracts[tickerWithContractIdx], null);
                            /* write to file that has only tickers with options. Later we 
                               will only use these files so we don't waste time on tickers w/o options.
                            */
                            wrFileAux.write(null, actTicker);
                            tickerWithContractIdx++;

                        } else {
                            System.out.println("option does not exist.");
                        }
                        if (shutDown == true){
                            System.out.println("shutDown detected...store last proccessed and close file..");
                            createOptionFilesTextArea.append("\nPause processing..wait for last item to finish..");
                            lastTickerProcessed = tickerIdx + 1;
                            lastTickerWithContractProccessed = tickerWithContractIdx;
                            wrFile.closeWr();
                            //write were we left off to file to use later to resume...
                            wrFile = new ioWrTextFiles(actContractFile+".his", false);
                            wrFile.write(null, Integer.toString(lastTickerProcessed));
                            wrFile.write(null, Integer.toString(lastTickerWithContractProccessed));
                            wrFile.closeWr();
                            wrFileAux.closeWr();
                            createOptionFilesTextArea.append("\nProcess paused with Ticker: " + lastTickerProcessed);
                            running = false;
                        }
                    }
                    running = false;
                    if (!shutDown) {
                        //not forced shutdown down so we are done naturally....
                        lastTickerProcessed = tickerIdx + 1;
                        lastTickerWithContractProccessed = tickerWithContractIdx;
                        wrFile.closeWr();
                        //write were we left off to file to use later to resume...
                        wrFile = new ioWrTextFiles(actContractFile + ".his", false);
                        wrFile.write(null, Integer.toString(lastTickerProcessed));
                        wrFile.write(null, Integer.toString(lastTickerWithContractProccessed));
                        wrFile.closeWr();
                        wrFileAux.closeWr();
                        createOptionFilesTextArea.append("\nProcess finished with Ticker: " + lastTickerProcessed);
                    }
                    System.out.println("done.");
                    createFilesThread.sleep(500);

                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
            System.out.println("shutDown for now...");
            createOptionFilesTextArea.append("\nProcessing now Paused.");
        }
        
    }
    private void createFilesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createFilesButtonActionPerformed
        // TODO add your handling code here:
        optionContractData[] contractDataToStore = null;
        
        if ((selectedExchangeStr == null)) {
            System.out.println("Cannot start, select exchange.");
            return;
        } else {
            System.out.println("Selected index is: " + selectedExchangeStr);

            // following fills exchangeData..
            System.out.println("reading selected exchange ticker file..");
            
            exchangeData = readTickersFromFile(selectedExchangeStr);
            createOptionFilesTextArea.append("\nRead " + exchangeData.numberOfTickers + " Tickers from file." );
            //create room for all tickers read from file....
            optionContracts = new optionContractData[exchangeData.numberOfTickers];
            System.out.println("done.");
            createNew = true;
            cfThread = new createFilesThread();
            
        }

    }//GEN-LAST:event_createFilesButtonActionPerformed

    private void pauseResumeButtonActionItem(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pauseResumeButtonActionItem
        // TODO add your handling code here:
        /* this button is used to interrupt a file 
           processing session as well as resume one from a previous session.
        */
        ioRdTextFiles rdFile = null;
        // if cfThread exists, means we have a session going that we will interrupt.
        if ((cfThread != null) && cfThread.running == true){
            cfThread.windDown();
            System.out.println("winding down cf thread..");
            createOptionFilesTextArea.append("\nPausing..wait");
        } else {
            if ((selectedExchangeStr == null)) {
                System.out.println("Cannot start, select exchange.");
                return;
            } else {
                System.out.println("Selected index is: " + selectedExchangeStr);

                // following fills exchangeData..
                System.out.println("reading selected exchange ticker file..");
                exchangeData = readTickersFromFile(selectedExchangeStr);
                //create room for all tickers read from file....
                optionContracts = new optionContractData[exchangeData.numberOfTickers];
                System.out.println("done.");
                createNew = false;
                rdFile = new ioRdTextFiles(actContractFile+".his", true);
                String tmpStr;
                if ((tmpStr = rdFile.read(true)) != null){
                    lastTickerProcessed = Integer.parseInt(tmpStr);   
                }
                if ((tmpStr = rdFile.read(true)) != null){
                    lastTickerWithContractProccessed = Integer.parseInt(tmpStr);   
                }
                rdFile.closeRd();
               
                createOptionFilesTextArea.append("\nResume Processing with ticker " + lastTickerProcessed);
                cfThread = new createFilesThread();
            }
        }
    }//GEN-LAST:event_pauseResumeButtonActionItem
    private readTickerFile readTickersFromFile(String exchange) {
        String tickerFileName = homeDirectory;
        int numOfTickers = 0;
        readTickerFile rtf;
        
        if (exchange.equals(NASQ1)) {
            tickerFileName += "nasdaqTickers1.txt.wo";
            actContractFile = homeDirectory + "nasContracts1.txt";
        }else if (exchange.equals(NASQ2)) {
            tickerFileName += "nasdaqTickers2.txt.wo";
            actContractFile = homeDirectory + "nasContracts2.txt";
        }else if (exchange.equals(NASQ3)) {
            tickerFileName += "nasdaqTickers3.txt.wo";
            actContractFile = homeDirectory + "nasContracts3.txt";
        }else if (exchange.equals(NASQ4)) {
            tickerFileName += "nasdaqTickers4.txt.wo";
            actContractFile = homeDirectory + "nasContracts4.txt";
        } else if (exchange.equals(NYSEQ1)) {
            tickerFileName += "nyseTickers1.txt.wo";
            actContractFile = homeDirectory + "nyseContracts1.txt";
        }else if (exchange.equals(NYSEQ2)) {
            tickerFileName += "nyseTickers2.txt.wo";
            actContractFile = homeDirectory + "nyseContracts2.txt";
        }else if (exchange.equals(NYSEQ3)) {
            tickerFileName += "nyseTickers3.txt.wo";
            actContractFile = homeDirectory + "nyseContracts3.txt";
        }else if (exchange.equals(NYSEQ4)) {
            tickerFileName += "nyseTickers4.txt.wo";
            actContractFile = homeDirectory + "nyseContracts4.txt";
        } else if (exchange.equals(NYSEQ5)) {
            tickerFileName += "nyseTickers5.txt.wo";
            actContractFile = homeDirectory + "nyseContracts5.txt";
        }else if (exchange.equals(NYSEQ6)) {
            tickerFileName += "nyseTickers6.txt.wo";
            actContractFile = homeDirectory + "nyseContracts6.txt";
        }else if (exchange.equals(NYSEQ7)) {
            tickerFileName += "nyseTickers7.txt.wo";
            actContractFile = homeDirectory + "nyseContracts7.txt";
        }else if (exchange.equals(NYSEQ8)) {
            tickerFileName += "nyseTickers8.txt.wo";
            actContractFile = homeDirectory + "nyseContracts8.txt";
        }else if (exchange.equals(WATCH1)) {
            tickerFileName += "watch1Tickers.txt.wo";
            actContractFile = homeDirectory + "watch1Contracts.txt";
        }else if (exchange.equals(SNP1)) {
            tickerFileName += "snp1Tickers.txt.wo";
            actContractFile = homeDirectory + "snp1Contracts.txt";
        }else if (exchange.equals(SNP2)) {
            tickerFileName += "snp2Tickers.txt.wo";
            actContractFile = homeDirectory + "snp2Contracts.txt";
        }else if (exchange.equals(DOW)) {
            tickerFileName += "dowTickers.txt.wo";
            actContractFile = homeDirectory + "dowContracts.txt";
        }else {
            tickerFileName = null;
            actContractFile = null;
            return null;
        }
        actTickersFile = tickerFileName;
        try {
            numOfTickers = myUtils.countLinesInFile(tickerFileName);
        } catch (IOException ex) {
            Logger.getLogger(displayOptionsWithUnusualVolumeDialogForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println("num of ticker are: " + numOfTickers);

        try {
            rtf = new readTickerFile(tickerFileName, numOfTickers);

        } catch (IOException ex) {
            Logger.getLogger(displayOptionsWithUnusualVolumeDialogForm.class.getName()).log(Level.SEVERE, null, ex);
            return (null);
        }
        return (rtf);
    }

    class optionData {

        boolean quoteAble;
        String stockTicker;
        String optionTicker;
        ibApi.quoteInfo chainInfo = new ibApi.quoteInfo();

        optionData() {
            quoteAble = false;
            stockTicker = null;
            optionTicker = null;
        }
    }

    public class readTickerFile {

        final int MAX_TICKERS = 4000;
        FileInputStream fis;
        BufferedReader bir;
        DataInputStream dis;
        String fileName = homeDirectory;
        String tmpStr = null;
        String actExchange = null;
        int numberOfTickers = 0;
        optionData tickerDataHere[];

        public readTickerFile(String tickerFileName, int numOfTickers) throws IOException {
            boolean split = false;
            int tickerNumber = numOfTickers - 1;
            int actTicker = 0;
            boolean trim = false;
            // if dealing with ".wo" files (with options), then don't trim tickers..
            trim = !(tickerFileName.indexOf(".wo") > 0);
            System.out.println("\ntrim = " + trim);
            if (numOfTickers > MAX_TICKERS) {
                System.out.println("numOfTickers too big!!!!!");
                return;
            }
            numberOfTickers = numOfTickers;
            optionData tickerData[] = new optionData[numOfTickers];
            tickerDataHere = tickerData;
            if (fileName.equals(null)) {
                return;
            }

            for (int idx = 0; idx < numOfTickers; idx++) {
                tickerData[idx] = new optionData();
            }
            try {
                fis = new FileInputStream(tickerFileName);
                dis = new DataInputStream(fis);
                bir = new BufferedReader(new InputStreamReader(fis));

                //read first line just is "Symbol" string....
                if ((!split) && (tmpStr = bir.readLine()) != null) {
                    // get rid of last char \
                    if (trim == true) {
                        tmpStr = tmpStr.substring(0, tmpStr.length() - 1);
                    }else {
                        
                    }
                } else {
                    split = true;
                }
                tickerNumber--;
                System.out.println("tmpStr = " + tmpStr);
                while ((tickerNumber != 0) && !split) {
                    if ((!split) && (tmpStr = bir.readLine()) != null) {
                        if (trim == true) {
                            // get rid of last char \
                            tmpStr = tmpStr.substring(0, tmpStr.length() - 1);
                        }
                        System.out.println("tmpStr = " + tmpStr);
                        //look for ^ in string and mark as don't quote..
                        if (tmpStr.indexOf('^') > 0) {
                            // found ^ so mark as no quote..
                            tickerData[actTicker].quoteAble = false;
                            System.out.println("^ found...don't quote it...");
                        } else {
                            tickerData[actTicker].quoteAble = true;
                        }
                        tickerData[actTicker].stockTicker = tmpStr;
                        tickerNumber--;
                        actTicker++;
                    } else {
                        split = true;
                    }

                }
                bir.close();
            } catch (Exception e) {
                System.out.println("error reading text from: " + tickerFileName + "(" + e + ").");
            }
        }
    }

    public class getOptionData {

        private final int CHAIN_ARRAY_PCSZ = 2;
        private final int CHAIN_ARRAY_ENTRIES = 800;
        private ibApi.quoteInfo[][] optionChainArray = new ibApi.quoteInfo[CHAIN_ARRAY_PCSZ][CHAIN_ARRAY_ENTRIES];
        private ibApi actIbApi = ibApi.getActApi();
        private ibApi.OptionChain actChain = actIbApi.getActOptionChain();
        private ibApi.quoteInfo qInfo = new ibApi.quoteInfo();
        private ibApi.quoteInfo cInfo = new ibApi.quoteInfo();
        String tmpStrike = null;
        private final int CALL = 0;
        private final int PUT = 1;
        private int optionChainCallArraySz = 0;
        private int optionChainPutArraySz = 0;
        boolean noErrors = true;

        public void justUpdate(String ticker) {
            noErrors = fillOptionData(ticker, true);
        }

        private boolean fillOptionData(String ticker, boolean justUpdate) {
            //String ticker = "aapl";
            int chainSize = 0;
            int chainNum = 0;
            int pcIdx = 0;
            boolean allGood = true;

            //initialize the option Chain array first..
            for (pcIdx = 0; pcIdx < CHAIN_ARRAY_PCSZ; pcIdx++) {
                for (int idx = 0; idx < CHAIN_ARRAY_ENTRIES; idx++) {
                    optionChainArray[pcIdx][idx] = null;
                }
            }

            if (justUpdate == false) {
                actChain.startNewChain();
                // we don't want streams on !!
                actChain.turnWithStreamsOn(false);
                allGood = actChain.getOptionChain(ticker);
                if (allGood == false) {
                    //System.out.println("error geting chain.");
                    return allGood;
                }
                //userMonth = null;

            }

            actChain.chainIdxReset();
            chainSize = actChain.chainLeft();
            if (false) {
                /* we should get call then put with the same strike as pairs. 
                 * if the strike price changes we increment the store idx (pcIdx).
                 * That's why we store the tmpStrike.
                 */
                for (chainNum = 0, pcIdx = 0; chainNum <= chainSize;) {
                    cInfo = actChain.chainGetNextOrdered(chainNum++);
                    if ((cInfo != null) && (cInfo.enStreaming == true)) {

                        /*
                         * check if we should move to next pair via bump pcidx
                         * take care of initial entry where tmpStrike == null.
                         */
                        if (tmpStrike == null) {
                            tmpStrike = String.valueOf(cInfo.strikePrice);
                        } else {
                            if (!String.valueOf(cInfo.strikePrice).equals(tmpStrike)) {
                                /*
                                 * strike changed so bump to next pair
                                 */
                                pcIdx++;
                                tmpStrike = String.valueOf(cInfo.strikePrice);
                            }
                        }
                        qInfo = actChain.getQuote(cInfo.optionSymbol, true /*
                         * option
                         */);

                        if (cInfo.cpType.equals("C")) {
                            /*
                             * was the call, so save then read for PUT
                             */
                            qInfo.optionSymbol = cInfo.optionSymbol;
                            qInfo.underlying = cInfo.underlying;
                            optionChainArray[CALL][pcIdx] = qInfo;

                            cInfo = actChain.chainGetNextOrdered(chainNum);
                            if ((cInfo != null) && (cInfo.enStreaming == true)) {
                                /* check if we should move to next pair via bump pcidx */
                                if (!String.valueOf(cInfo.strikePrice).equals(tmpStrike)) {
                                    /* strike changed so bump to next pair */
                                    pcIdx++;
                                    tmpStrike = String.valueOf(cInfo.strikePrice);
                                }
                                qInfo = actChain.getQuote(cInfo.optionSymbol, true /*
                                 * option
                                 */);
                                qInfo.optionSymbol = cInfo.optionSymbol;
                                qInfo.underlying = cInfo.underlying;
                                optionChainArray[PUT][pcIdx] = qInfo;
                            } else {
                            }

                        } else {
                            /*
                             * must be PUT, so save then read for CALL
                             */
                            qInfo.optionSymbol = cInfo.optionSymbol;
                            qInfo.underlying = cInfo.underlying;
                            optionChainArray[PUT][pcIdx] = qInfo;

                            cInfo = actChain.chainGetNextOrdered(chainNum);
                            if ((cInfo != null) && (cInfo.enStreaming == true)) {
                                /* check if we should move to next pair via bump pcidx */
                                if (!String.valueOf(cInfo.strikePrice).equals(tmpStrike)) {
                                    /* strike changed so bump to next pair */
                                    pcIdx++;
                                    tmpStrike = String.valueOf(cInfo.strikePrice);
                                }
                                qInfo = actChain.getQuote(cInfo.optionSymbol, true /*
                                 * option
                                 */);
                                qInfo.optionSymbol = cInfo.optionSymbol;
                                qInfo.underlying = cInfo.underlying;
                                optionChainArray[CALL][pcIdx] = qInfo;
                            } else {
                            }

                        }
                        chainNum++;
                    }

                }
            
                optionChainCallArraySz = pcIdx;
                optionChainPutArraySz = pcIdx;
            }
            return allGood;

        }

        // this will use exchangeData to get option quote data from IB IPA...
        public getOptionData(String ticker) {
            noErrors = fillOptionData(ticker, false /* just update */);

        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(createOptionFilesForExchangesDialogForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                createOptionFilesForExchangesDialogForm dialog = new createOptionFilesForExchangesDialogForm(new javax.swing.JFrame(), true);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton closeButton;
    private javax.swing.JButton createFilesButton;
    private javax.swing.JTextArea createOptionFilesTextArea;
    private javax.swing.JComboBox indexComboBox;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton pauseResumeButton;
    // End of variables declaration//GEN-END:variables
}
